import {
  generateKeyPair,
  randomBytes,
  createHash,
  Hash,
  scrypt,
  createCipheriv,
  createDecipheriv,
  pbkdf2Sync,
} from 'crypto';
import { TextEncoder, TextDecoder, promisify } from 'util';
import { createReadStream } from 'fs';
// Uint8Array encoder/decoder
function encode(src: string) {
  const encoder = new TextEncoder();
  return encoder.encode(src);
}
function decode(src: Uint8Array) {
  const decoder = new TextDecoder();
  return decoder.decode(src);
}
// console.log(encode('hello'));
// console.log(decode(encode('hello')));
// end Uint8Array encoder/decoder

const genKP = promisify(generateKeyPair);

const oldstuff = {
  a() {
    // https://nodejs.org/api/crypto.html#crypto_crypto_generatekeypair_type_options_callback
    // enum hashes {
    //   'RSA-MD4',
    //   'RSA-MD5',
    //   'RSA-MDC2',
    //   'RSA-RIPEMD160',
    //   'RSA-SHA1',
    //   'RSA-SHA1-2',
    //   'RSA-SHA224',
    //   'RSA-SHA256',
    //   'RSA-SHA3-224',
    //   'RSA-SHA3-256',
    //   'RSA-SHA3-384',
    //   'RSA-SHA3-512',
    //   'RSA-SHA384',
    //   'RSA-SHA512',
    //   'RSA-SHA512/224',
    //   'RSA-SHA512/256',
    //   'RSA-SM3',
    //   'blake2b512',
    //   'blake2s256',
    //   'id-rsassa-pkcs1-v1_5-with-sha3-224',
    //   'id-rsassa-pkcs1-v1_5-with-sha3-256',
    //   'id-rsassa-pkcs1-v1_5-with-sha3-384',
    //   'id-rsassa-pkcs1-v1_5-with-sha3-512',
    //   'md4',
    //   'md4WithRSAEncryption',
    //   'md5',
    //   'md5-sha1',
    //   'md5WithRSAEncryption',
    //   'mdc2',
    //   'mdc2WithRSA',
    //   'ripemd',
    //   'ripemd160',
    //   'ripemd160WithRSA',
    //   'rmd160',
    //   'sha1',
    //   'sha1WithRSAEncryption',
    //   'sha224',
    //   'sha224WithRSAEncryption',
    //   'sha256',
    //   'sha256WithRSAEncryption',
    //   'sha3-224',
    //   'sha3-256',
    //   'sha3-384',
    //   'sha3-512',
    //   'sha384',
    //   'sha384WithRSAEncryption',
    //   'sha512',
    //   'sha512-224',
    //   'sha512-224WithRSAEncryption',
    //   'sha512-256',
    //   'sha512-256WithRSAEncryption',
    //   'sha512WithRSAEncryption',
    //   'shake128',
    //   'shake256',
    //   'sm3',
    //   'sm3WithRSAEncryption',
    //   'ssl3-md5',
    //   'ssl3-sha1',
    //   'whirlpool',
    // }
    // enum ciphers {
    //   'aes-128-cbc',
    //   'aes-128-cbc-hmac-sha1',
    //   'aes-128-cbc-hmac-sha256',
    //   'aes-128-ccm',
    //   'aes-128-cfb',
    //   'aes-128-cfb1',
    //   'aes-128-cfb8',
    //   'aes-128-ctr',
    //   'aes-128-ecb',
    //   'aes-128-gcm',
    //   'aes-128-ocb',
    //   'aes-128-ofb',
    //   'aes-128-xts',
    //   'aes-192-cbc',
    //   'aes-192-ccm',
    //   'aes-192-cfb',
    //   'aes-192-cfb1',
    //   'aes-192-cfb8',
    //   'aes-192-ctr',
    //   'aes-192-ecb',
    //   'aes-192-gcm',
    //   'aes-192-ocb',
    //   'aes-192-ofb',
    //   'aes-256-cbc',
    //   'aes-256-cbc-hmac-sha1',
    //   'aes-256-cbc-hmac-sha256',
    //   'aes-256-ccm',
    //   'aes-256-cfb',
    //   'aes-256-cfb1',
    //   'aes-256-cfb8',
    //   'aes-256-ctr',
    //   'aes-256-ecb',
    //   'aes-256-gcm',
    //   'aes-256-ocb',
    //   'aes-256-ofb',
    //   'aes-256-xts',
    //   'aes128',
    //   'aes128-wrap',
    //   'aes192',
    //   'aes192-wrap',
    //   'aes256',
    //   'aes256-wrap',
    //   'aria-128-cbc',
    //   'aria-128-ccm',
    //   'aria-128-cfb',
    //   'aria-128-cfb1',
    //   'aria-128-cfb8',
    //   'aria-128-ctr',
    //   'aria-128-ecb',
    //   'aria-128-gcm',
    //   'aria-128-ofb',
    //   'aria-192-cbc',
    //   'aria-192-ccm',
    //   'aria-192-cfb',
    //   'aria-192-cfb1',
    //   'aria-192-cfb8',
    //   'aria-192-ctr',
    //   'aria-192-ecb',
    //   'aria-192-gcm',
    //   'aria-192-ofb',
    //   'aria-256-cbc',
    //   'aria-256-ccm',
    //   'aria-256-cfb',
    //   'aria-256-cfb1',
    //   'aria-256-cfb8',
    //   'aria-256-ctr',
    //   'aria-256-ecb',
    //   'aria-256-gcm',
    //   'aria-256-ofb',
    //   'aria128',
    //   'aria192',
    //   'aria256',
    //   'bf',
    //   'bf-cbc',
    //   'bf-cfb',
    //   'bf-ecb',
    //   'bf-ofb',
    //   'blowfish',
    //   'camellia-128-cbc',
    //   'camellia-128-cfb',
    //   'camellia-128-cfb1',
    //   'camellia-128-cfb8',
    //   'camellia-128-ctr',
    //   'camellia-128-ecb',
    //   'camellia-128-ofb',
    //   'camellia-192-cbc',
    //   'camellia-192-cfb',
    //   'camellia-192-cfb1',
    //   'camellia-192-cfb8',
    //   'camellia-192-ctr',
    //   'camellia-192-ecb',
    //   'camellia-192-ofb',
    //   'camellia-256-cbc',
    //   'camellia-256-cfb',
    //   'camellia-256-cfb1',
    //   'camellia-256-cfb8',
    //   'camellia-256-ctr',
    //   'camellia-256-ecb',
    //   'camellia-256-ofb',
    //   'camellia128',
    //   'camellia192',
    //   'camellia256',
    //   'cast',
    //   'cast-cbc',
    //   'cast5-cbc',
    //   'cast5-cfb',
    //   'cast5-ecb',
    //   'cast5-ofb',
    //   'chacha20',
    //   'chacha20-poly1305',
    //   'des',
    //   'des-cbc',
    //   'des-cfb',
    //   'des-cfb1',
    //   'des-cfb8',
    //   'des-ecb',
    //   'des-ede',
    //   'des-ede-cbc',
    //   'des-ede-cfb',
    //   'des-ede-ecb',
    //   'des-ede-ofb',
    //   'des-ede3',
    //   'des-ede3-cbc',
    //   'des-ede3-cfb',
    //   'des-ede3-cfb1',
    //   'des-ede3-cfb8',
    //   'des-ede3-ecb',
    //   'des-ede3-ofb',
    //   'des-ofb',
    //   'des3',
    //   'des3-wrap',
    //   'desx',
    //   'desx-cbc',
    //   'id-aes128-CCM',
    //   'id-aes128-GCM',
    //   'id-aes128-wrap',
    //   'id-aes128-wrap-pad',
    //   'id-aes192-CCM',
    //   'id-aes192-GCM',
    //   'id-aes192-wrap',
    //   'id-aes192-wrap-pad',
    //   'id-aes256-CCM',
    //   'id-aes256-GCM',
    //   'id-aes256-wrap',
    //   'id-aes256-wrap-pad',
    //   'id-smime-alg-CMS3DESwrap',
    //   'idea',
    //   'idea-cbc',
    //   'idea-cfb',
    //   'idea-ecb',
    //   'idea-ofb',
    //   'rc2',
    //   'rc2-128',
    //   'rc2-40',
    //   'rc2-40-cbc',
    //   'rc2-64',
    //   'rc2-64-cbc',
    //   'rc2-cbc',
    //   'rc2-cfb',
    //   'rc2-ecb',
    //   'rc2-ofb',
    //   'rc4',
    //   'rc4-40',
    //   'rc4-hmac-md5',
    //   'seed',
    //   'seed-cbc',
    //   'seed-cfb',
    //   'seed-ecb',
    //   'seed-ofb',
    //   'sm4',
    //   'sm4-cbc',
    //   'sm4-cfb',
    //   'sm4-ctr',
    //   'sm4-ecb',
    //   'sm4-ofb',
    // }
    // enum genKeyPair__type {
    //   'rsa',
    //   'dsa',
    //   'ec',
    //   'ed25519',
    //   'ed448',
    //   'x25519',
    //   'x448',
    //   'dh',
    // }
    // enum publicKeyEncoding_type {
    //   'pkcs1',
    //   'spki',
    // }
    // enum privateKeyEncoding_type {
    //   'pkcs1',
    //   'pkcs8',
    //   'sec1',
    // }
    // enum keyEncoding_format {
    //   'pem',
    //   'der',
    // }
    // interface genKeyPair {
    //   type: keyof typeof genKeyPair__type;
    //   options: {
    //     modulusLength: number;
    //     publicExponent: number;
    //     divisorLength: number;
    //     namedCurve: string;
    //     prime: Buffer;
    //     primeLength: number;
    //     generator: number;
    //     groupName: string;
    //     publicKeyEncoding: {
    //       // https://nodejs.org/api/crypto.html#crypto_keyobject_export_options
    //       type: keyof typeof publicKeyEncoding_type;
    //       format: keyof typeof keyEncoding_format;
    //     };
    //     privateKeyEncoding: {
    //       // https://nodejs.org/api/crypto.html#crypto_keyobject_export_options
    //       type: keyof typeof privateKeyEncoding_type;
    //       format: keyof typeof keyEncoding_format;
    //       cipher: string;
    //       passphrase: string | Buffer;
    //     };
    //   };
    // }
    // interface Async_params {
    //   type: keyof typeof genKeyPair__type;
    //   options: {
    //     modulusLength?: number;
    //     pubEncodeType: keyof typeof publicKeyEncoding_type;
    //     pubEncodeFormat: keyof typeof keyEncoding_format;
    //     privEncodeType: keyof typeof privateKeyEncoding_type;
    //     privEncodeFormat: keyof typeof keyEncoding_format;
    //     privCipher?: string; // console.log(crypto.getCiphers())
    //     passphrase?: string;
    //   }
    // }
    // interface Async {
    //   genKeyPair: (params: Async_params) => string;
    // }
    // const ASYNC: Async = {
    //   genKeyPair: (
    //     type,
    //     modulusLength,
    //     pubEncodeType,
    //     pubEncodeFormat,
    //     privEncodeType,
    //     privEncodeFormat,
    //     privCipher,
    //     passphrase
    //   ) => {
    //     return generateKeyPair(type, {
    //       modulusLength,
    //       publicKeyEncoding: {
    //         type: pubEncodeType,
    //         format: pubEncodeFormat,
    //       },
    //       privateKeyEncoding: {
    //         type: privEncodeType,
    //         format: privEncodeFormat,
    //         cipher: privCipher,
    //         passphrase,
    //       },
    //     }, (err: string, publicKey: any, privateKey: any) => {
    //       // Handle errors and use the generated key pair.
    //       if (err) {
    //         throw new Error(err);
    //       }
    //       console.log(`publicKey: ${publicKey} \nprivateKey: ${privateKey}`);
    //     });
    //   },
    // };
    // const kp = ASYNC.genKeyPair({
    //   type: 'rsa',
    //   modulusLength: 4096,
    //   pubEncodeType: 'spki',
    //   pubEncodeFormat: 'pem',
    //   privEncodeFormat: 'pem',
    //   privEncodeType: 'pkcs8',
    // });
    // const ciph = getHashes();
    // console.log(ciph)
  },
};

async function newKP() {
  let data: { publicKey: string; privateKey: string } | void;
  try {
    data = await genKP('rsa', {
      modulusLength: 4096,
      publicKeyEncoding: {
        type: 'spki',
        format: 'pem',
      },
      privateKeyEncoding: {
        type: 'pkcs8',
        format: 'pem',
        cipher: 'aes-256-cbc',
        passphrase: 'top secret',
      },
    });
  } catch (err) {
    data = console.error(err);
  }
  return data;
}

// async console logger
const async = {
  console: {
    log: async (src: Promise<any>) =>
      await src.then((res: any) => {
        return console.log(res);
      }),
    error: async (src: Promise<any>) =>
      await src.then((res: any) => console.error(res)),
    warn: async (src: Promise<any>) =>
      await src.then((res: any) => console.warn(res)),
    info: async (src: Promise<any>) =>
      await src.then((res: any) => console.info(res)),
  },
};

// const kp = newKP();
// async.console.log(kp);
const ssl_digest_algorithms = {
  // openssl list -digest-algorithms
  MD4: 'MD4',
  MD5: 'MD5',
  RIPEMD160: 'RIPEMD160',
  SHA1: 'SHA1',
  RSA_SHA1: 'RSA-SHA1',
  SHA224: 'SHA224',
  SHA256: 'SHA256',
  SHA3_224: 'SHA3-224',
  SHA3_256: 'SHA3-256',
  SHA3_384: 'SHA3-384',
  SHA3_512: 'SHA3-512',
  SHA384: 'SHA384',
  SHA512: 'SHA512',
  SHA512_224: 'SHA512-224',
  SHA512_256: 'SHA512-256',
  SM3: 'SM3',
  BLAKE2b512: 'BLAKE2b512',
  BLAKE2s256: 'BLAKE2s256',
  MD5_SHA1: 'MD5-SHA1',
  SHAKE128: 'SHAKE128',
  SHAKE256: 'SHAKE256',
  whirlpool: 'whirlpool',
};

// https://nodejs.org/api/crypto.html#crypto_crypto_generatekeypair_type_options_callback
enum hashes {
  'RSA-MD4',
  'RSA-MD5',
  'RSA-MDC2',
  'RSA-RIPEMD160',
  'RSA-SHA1',
  'RSA-SHA1-2',
  'RSA-SHA224',
  'RSA-SHA256',
  'RSA-SHA3-224',
  'RSA-SHA3-256',
  'RSA-SHA3-384',
  'RSA-SHA3-512',
  'RSA-SHA384',
  'RSA-SHA512',
  'RSA-SHA512/224',
  'RSA-SHA512/256',
  'RSA-SM3',
  'blake2b512',
  'blake2s256',
  'id-rsassa-pkcs1-v1_5-with-sha3-224',
  'id-rsassa-pkcs1-v1_5-with-sha3-256',
  'id-rsassa-pkcs1-v1_5-with-sha3-384',
  'id-rsassa-pkcs1-v1_5-with-sha3-512',
  'md4',
  'md4WithRSAEncryption',
  'md5',
  'md5-sha1',
  'md5WithRSAEncryption',
  'mdc2',
  'mdc2WithRSA',
  'ripemd',
  'ripemd160',
  'ripemd160WithRSA',
  'rmd160',
  'sha1',
  'sha1WithRSAEncryption',
  'sha224',
  'sha224WithRSAEncryption',
  'sha256',
  'sha256WithRSAEncryption',
  'sha3-224',
  'sha3-256',
  'sha3-384',
  'sha3-512',
  'sha384',
  'sha384WithRSAEncryption',
  'sha512',
  'sha512-224',
  'sha512-224WithRSAEncryption',
  'sha512-256',
  'sha512-256WithRSAEncryption',
  'sha512WithRSAEncryption',
  'shake128',
  'shake256',
  'sm3',
  'sm3WithRSAEncryption',
  'ssl3-md5',
  'ssl3-sha1',
  'whirlpool',
}
enum ciphers {
  'aes-128-cbc',
  'aes-128-cbc-hmac-sha1',
  'aes-128-cbc-hmac-sha256',
  'aes-128-ccm',
  'aes-128-cfb',
  'aes-128-cfb1',
  'aes-128-cfb8',
  'aes-128-ctr',
  'aes-128-ecb',
  'aes-128-gcm',
  'aes-128-ocb',
  'aes-128-ofb',
  'aes-128-xts',
  'aes-192-cbc',
  'aes-192-ccm',
  'aes-192-cfb',
  'aes-192-cfb1',
  'aes-192-cfb8',
  'aes-192-ctr',
  'aes-192-ecb',
  'aes-192-gcm',
  'aes-192-ocb',
  'aes-192-ofb',
  'aes-256-cbc',
  'aes-256-cbc-hmac-sha1',
  'aes-256-cbc-hmac-sha256',
  'aes-256-ccm',
  'aes-256-cfb',
  'aes-256-cfb1',
  'aes-256-cfb8',
  'aes-256-ctr',
  'aes-256-ecb',
  'aes-256-gcm',
  'aes-256-ocb',
  'aes-256-ofb',
  'aes-256-xts',
  'aes128',
  'aes128-wrap',
  'aes192',
  'aes192-wrap',
  'aes256',
  'aes256-wrap',
  'aria-128-cbc',
  'aria-128-ccm',
  'aria-128-cfb',
  'aria-128-cfb1',
  'aria-128-cfb8',
  'aria-128-ctr',
  'aria-128-ecb',
  'aria-128-gcm',
  'aria-128-ofb',
  'aria-192-cbc',
  'aria-192-ccm',
  'aria-192-cfb',
  'aria-192-cfb1',
  'aria-192-cfb8',
  'aria-192-ctr',
  'aria-192-ecb',
  'aria-192-gcm',
  'aria-192-ofb',
  'aria-256-cbc',
  'aria-256-ccm',
  'aria-256-cfb',
  'aria-256-cfb1',
  'aria-256-cfb8',
  'aria-256-ctr',
  'aria-256-ecb',
  'aria-256-gcm',
  'aria-256-ofb',
  'aria128',
  'aria192',
  'aria256',
  'bf',
  'bf-cbc',
  'bf-cfb',
  'bf-ecb',
  'bf-ofb',
  'blowfish',
  'camellia-128-cbc',
  'camellia-128-cfb',
  'camellia-128-cfb1',
  'camellia-128-cfb8',
  'camellia-128-ctr',
  'camellia-128-ecb',
  'camellia-128-ofb',
  'camellia-192-cbc',
  'camellia-192-cfb',
  'camellia-192-cfb1',
  'camellia-192-cfb8',
  'camellia-192-ctr',
  'camellia-192-ecb',
  'camellia-192-ofb',
  'camellia-256-cbc',
  'camellia-256-cfb',
  'camellia-256-cfb1',
  'camellia-256-cfb8',
  'camellia-256-ctr',
  'camellia-256-ecb',
  'camellia-256-ofb',
  'camellia128',
  'camellia192',
  'camellia256',
  'cast',
  'cast-cbc',
  'cast5-cbc',
  'cast5-cfb',
  'cast5-ecb',
  'cast5-ofb',
  'chacha20',
  'chacha20-poly1305',
  'des',
  'des-cbc',
  'des-cfb',
  'des-cfb1',
  'des-cfb8',
  'des-ecb',
  'des-ede',
  'des-ede-cbc',
  'des-ede-cfb',
  'des-ede-ecb',
  'des-ede-ofb',
  'des-ede3',
  'des-ede3-cbc',
  'des-ede3-cfb',
  'des-ede3-cfb1',
  'des-ede3-cfb8',
  'des-ede3-ecb',
  'des-ede3-ofb',
  'des-ofb',
  'des3',
  'des3-wrap',
  'desx',
  'desx-cbc',
  'id-aes128-CCM',
  'id-aes128-GCM',
  'id-aes128-wrap',
  'id-aes128-wrap-pad',
  'id-aes192-CCM',
  'id-aes192-GCM',
  'id-aes192-wrap',
  'id-aes192-wrap-pad',
  'id-aes256-CCM',
  'id-aes256-GCM',
  'id-aes256-wrap',
  'id-aes256-wrap-pad',
  'id-smime-alg-CMS3DESwrap',
  'idea',
  'idea-cbc',
  'idea-cfb',
  'idea-ecb',
  'idea-ofb',
  'rc2',
  'rc2-128',
  'rc2-40',
  'rc2-40-cbc',
  'rc2-64',
  'rc2-64-cbc',
  'rc2-cbc',
  'rc2-cfb',
  'rc2-ecb',
  'rc2-ofb',
  'rc4',
  'rc4-40',
  'rc4-hmac-md5',
  'seed',
  'seed-cbc',
  'seed-cfb',
  'seed-ecb',
  'seed-ofb',
  'sm4',
  'sm4-cbc',
  'sm4-cfb',
  'sm4-ctr',
  'sm4-ecb',
  'sm4-ofb',
}
type HexBase64BinaryEncoding = 'binary' | 'base64' | 'hex';

// Check if variable is an Error
function isError(obj) {
  return t.constructor === Error;
}
const t = new Error('tasdad');
// console.log(isError(t));

class CryptoHelper {
  // generate random seed from randomBytes with size: 512
  seed() {
    return randomBytes(512, (err, buf) => {
      if (err) throw err;
      console.log(`${buf.length} bytes of random data: ${buf.toString('hex')}`);
    });
  }

  hash(seed: string, algorithm: keyof typeof hashes = 'sha256') {
    return createHash(algorithm)
      .update(seed)
      .digest();
  }

  salt(bytes = 16) {
    return randomBytes(bytes).toString('hex');
  }

  /**
   * Returns a hexadecimal string representing the encrypted data.
   * ❗The salt should be as unique as possible. It is recommended that a salt is random and at least 16 bytes long❗
   * @memberof CryptoHelper
   */
  encrypt(
    data: any,
    password: string,
    algorithm: keyof typeof ciphers = 'aes-256-cbc'
  ) {
    // https://nodejs.org/api/crypto.html#crypto_class_cipher
    // Key length is dependent on the algorithm. In the case for aes192, it is 24 bytes (192 bits).
    const key = pbkdf2Sync(
      password,
      this.salt(),
      1000,
      256 / 8 / 2,
      'sha512'
    ).toString(
      // hash
      'hex'
    );
    // console.log('Key: %s \nLength: %d', key, key.length);

    const iv = randomBytes(key.length / 2); // Initialization vector.

    if (!key) throw new Error('CryptoHelper.encrypt: error generating key');
    const cipher = createCipheriv(algorithm, key, iv);

    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
  }

  async decrypt(
    data: string,
    password: string,
    algorithm: keyof typeof ciphers = 'aes-256-cbc'
  ) {
    // Key length is dependent on the algorithm. In the case for aes192, it is 24 bytes (192 bits).
    const key = pbkdf2Sync(
      password,
      this.salt(),
      1000,
      256 / 8 / 2,
      'sha512'
    ).toString(
      // hash
      'hex'
    );
    // console.log('Key: %s \nLength: %d', key, key.length);

    const iv = randomBytes(key.length / 2); // Initialization vector.

    if (!key) throw new Error('CryptoHelper.encrypt: error generating key');
    const decipher = createDecipheriv(algorithm, key, iv);

    let decrypted = decipher.update(data, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  }
}
const CH = new CryptoHelper();

const encrypted = CH.encrypt('data here', 'password');
const decrypted = CH.decrypt(encrypted, 'password');

console.log(encrypted);
